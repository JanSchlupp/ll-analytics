{% extends "base.html" %}

{% block title %}Compare Players - LL Analytics{% endblock %}

{% block content %}
<div x-data="compareApp()">
    <!-- Header -->
    <div class="mb-6">
        <h1 class="text-3xl font-bold text-gray-900">Compare Players</h1>
        <p class="text-gray-600 mt-1">Side-by-side analysis of up to 3 players</p>
    </div>

    <!-- Player Selection -->
    <div class="bg-white rounded-lg shadow p-4 mb-6">
        <div class="flex flex-wrap gap-4 items-end">
            <!-- Player Search -->
            <div class="flex-1 min-w-[200px]">
                <label class="block text-sm font-medium text-gray-700 mb-1">Add Player</label>
                <div class="relative">
                    <input type="text"
                           x-model="searchQuery"
                           @input.debounce.200ms="searchPlayers()"
                           @keydown.enter="addFirstResult()"
                           @keydown.escape="searchResults = []"
                           placeholder="Search players..."
                           :disabled="selectedPlayers.length >= 3"
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm disabled:bg-gray-100">
                    <!-- Autocomplete dropdown -->
                    <div x-show="searchResults.length > 0" x-cloak
                         @click.outside="searchResults = []"
                         class="absolute left-0 mt-1 w-full bg-white rounded-lg shadow-lg z-50 max-h-48 overflow-y-auto">
                        <template x-for="player in searchResults" :key="player">
                            <button @click="addPlayer(player)"
                                    class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-indigo-100 text-sm"
                                    x-text="player"></button>
                        </template>
                    </div>
                </div>
            </div>

            <!-- Season Selector -->
            <div class="min-w-[150px]">
                <label class="block text-sm font-medium text-gray-700 mb-1">Season</label>
                <select x-model="selectedSeason"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 text-sm">
                    {% for s in seasons %}
                    <option value="{{ s }}" {% if s == default_season %}selected{% endif %}>Season {{ s }}</option>
                    {% endfor %}
                </select>
            </div>

            <!-- Compare Button -->
            <button @click="compare()"
                    :disabled="selectedPlayers.length < 2 || comparing"
                    class="px-6 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                <span x-show="!comparing">Compare</span>
                <span x-show="comparing">Loading...</span>
            </button>
        </div>

        <!-- Selected Player Chips -->
        <div class="flex gap-2 mt-3" x-show="selectedPlayers.length > 0">
            <template x-for="(player, idx) in selectedPlayers" :key="player">
                <span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium"
                      :class="chipColors[idx]">
                    <span x-text="player"></span>
                    <button @click="removePlayer(idx)" class="hover:opacity-70">&times;</button>
                </span>
            </template>
        </div>
    </div>

    <!-- Results -->
    <div x-show="hasResults" x-cloak class="space-y-6">

        <!-- Cumulative Surprise Chart -->
        <div class="bg-white rounded-lg shadow p-4">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Cumulative Surprise</h3>
            <div class="chart-container">
                <canvas id="surpriseCompareChart"></canvas>
            </div>
        </div>

        <!-- Category Radar Chart -->
        <div class="bg-white rounded-lg shadow p-4">
            <h3 class="text-lg font-medium text-gray-900 mb-4">Category Profile</h3>
            <div class="chart-container" style="height: 400px;">
                <canvas id="categoryRadarChart"></canvas>
            </div>
        </div>

        <!-- Stats Comparison Table -->
        <div class="bg-white rounded-lg shadow overflow-hidden">
            <h3 class="text-lg font-medium text-gray-900 p-4 pb-2">Stats Comparison</h3>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Metric</th>
                        <template x-for="(player, idx) in selectedPlayers" :key="player">
                            <th class="px-6 py-3 text-center text-xs font-medium uppercase"
                                :class="chipTextColors[idx]"
                                x-text="player"></th>
                        </template>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
                    <template x-for="row in statsRows" :key="row.label">
                        <tr class="hover:bg-gray-50">
                            <td class="px-6 py-3 text-sm font-medium text-gray-900" x-text="row.label"></td>
                            <template x-for="(player, idx) in selectedPlayers" :key="player">
                                <td class="px-6 py-3 text-center text-sm text-gray-700" x-text="row.values[idx] ?? '-'"></td>
                            </template>
                        </tr>
                    </template>
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function compareApp() {
    return {
        searchQuery: '',
        searchResults: [],
        selectedPlayers: [],
        selectedSeason: '{{ default_season }}',
        comparing: false,
        hasResults: false,
        statsRows: [],
        surpriseChart: null,
        radarChart: null,
        chipColors: [
            'bg-indigo-100 text-indigo-800',
            'bg-green-100 text-green-800',
            'bg-amber-100 text-amber-800',
        ],
        chipTextColors: ['text-indigo-600', 'text-green-600', 'text-amber-600'],

        async searchPlayers() {
            if (this.searchQuery.length < 2) { this.searchResults = []; return; }
            try {
                const resp = await fetch(`/api/players/search/autocomplete?q=${encodeURIComponent(this.searchQuery)}`);
                const data = await resp.json();
                this.searchResults = (data.results || data || [])
                    .filter(p => !this.selectedPlayers.includes(p))
                    .slice(0, 5);
            } catch (e) { this.searchResults = []; }
        },

        addPlayer(player) {
            if (this.selectedPlayers.length < 3 && !this.selectedPlayers.includes(player)) {
                this.selectedPlayers.push(player);
            }
            this.searchQuery = '';
            this.searchResults = [];
        },

        addFirstResult() {
            if (this.searchResults.length > 0) this.addPlayer(this.searchResults[0]);
        },

        removePlayer(idx) {
            this.selectedPlayers.splice(idx, 1);
            this.hasResults = false;
        },

        async compare() {
            if (this.selectedPlayers.length < 2) return;
            this.comparing = true;
            this.hasResults = false;

            try {
                // Fetch data for all players in parallel
                const fetches = this.selectedPlayers.map(async (username) => {
                    const [surpriseResp, playerResp] = await Promise.all([
                        fetch(`/api/metrics/surprise/player/${username}?season=${this.selectedSeason}`),
                        fetch(`/api/players/${username}`),
                    ]);
                    const surprise = await surpriseResp.json();
                    const player = await playerResp.json();
                    return { username, surprise, player };
                });

                const results = await Promise.all(fetches);

                // Also fetch breadth for each player
                const breadthFetches = this.selectedPlayers.map(async (username) => {
                    try {
                        const resp = await fetch(`/api/metrics/breadth/player/${username}?season=${this.selectedSeason}`);
                        return await resp.json();
                    } catch { return null; }
                });
                const breadthResults = await Promise.all(breadthFetches);

                // Also fetch luck for each player
                const luckFetches = this.selectedPlayers.map(async (username) => {
                    try {
                        const resp = await fetch(`/api/metrics/luck/player/${username}?season=${this.selectedSeason}`);
                        return await resp.json();
                    } catch { return null; }
                });
                const luckResults = await Promise.all(luckFetches);

                // Build surprise chart
                this.$nextTick(() => {
                    this.renderSurpriseChart(results);
                    this.renderRadarChart(results);
                });

                // Build stats table
                this.statsRows = this.buildStatsRows(results, breadthResults, luckResults);
                this.hasResults = true;
            } catch (e) {
                console.error('Compare failed:', e);
            }
            this.comparing = false;
        },

        renderSurpriseChart(results) {
            const ctx = document.getElementById('surpriseCompareChart');
            if (!ctx) return;
            if (this.surpriseChart) this.surpriseChart.destroy();

            const datasets = results.map((r, i) => {
                const details = r.surprise?.data?.details || [];
                return {
                    label: r.username,
                    data: details.map(d => ({ x: d.match_day, y: d.cumulative })),
                    borderColor: LLCharts.COLOR_PALETTE[i],
                    backgroundColor: 'transparent',
                    tension: 0.1,
                    pointRadius: 2,
                };
            });

            // Find all unique match days for labels
            const allDays = new Set();
            datasets.forEach(ds => ds.data.forEach(pt => allDays.add(pt.x)));
            const labels = [...allDays].sort((a, b) => a - b).map(d => 'Day ' + d);

            // Convert point data to array aligned with labels
            const dayList = [...allDays].sort((a, b) => a - b);
            datasets.forEach(ds => {
                const dayMap = {};
                ds.data.forEach(pt => dayMap[pt.x] = pt.y);
                ds.data = dayList.map(d => dayMap[d] ?? null);
            });

            this.surpriseChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true } },
                    scales: {
                        y: { title: { display: true, text: 'Cumulative Surprise' } },
                    },
                    spanGaps: true,
                },
            });
        },

        renderRadarChart(results) {
            const ctx = document.getElementById('categoryRadarChart');
            if (!ctx) return;
            if (this.radarChart) this.radarChart.destroy();

            // Get category stats from player data
            const allCats = new Set();
            results.forEach(r => {
                const stats = r.player?.category_stats || [];
                stats.forEach(s => allCats.add(s.name));
            });
            const categories = [...allCats].sort();

            const datasets = results.map((r, i) => {
                const statsMap = {};
                (r.player?.category_stats || []).forEach(s => {
                    statsMap[s.name] = Math.round((s.correct_pct || 0) * 100);
                });
                return {
                    label: r.username,
                    data: categories.map(c => statsMap[c] ?? 0),
                };
            });

            this.radarChart = LLCharts.createRadarChart(ctx.getContext('2d'), {
                labels: categories,
                datasets,
            }, { title: 'Category Performance (%)' });
        },

        buildStatsRows(results, breadthResults, luckResults) {
            const rows = [];
            const val = (r, path) => {
                const parts = path.split('.');
                let obj = r;
                for (const p of parts) { obj = obj?.[p]; }
                return obj;
            };

            rows.push({
                label: 'Total Surprise',
                values: results.map(r => {
                    const v = val(r, 'surprise.data.total_surprise');
                    return v != null ? (v > 0 ? '+' : '') + v.toFixed(2) : '-';
                }),
            });

            rows.push({
                label: 'Avg Surprise',
                values: results.map(r => {
                    const v = val(r, 'surprise.data.avg_surprise');
                    return v != null ? v.toFixed(3) : '-';
                }),
            });

            rows.push({
                label: 'Questions',
                values: results.map(r => {
                    const v = val(r, 'surprise.data.questions');
                    return v != null ? v : '-';
                }),
            });

            rows.push({
                label: 'Breadth Score',
                values: breadthResults.map(b => {
                    const v = b?.data?.breadth_score;
                    return v != null ? v.toFixed(3) : '-';
                }),
            });

            rows.push({
                label: 'Total Luck',
                values: luckResults.map(l => {
                    const v = l?.data?.total_luck;
                    return v != null ? (v > 0 ? '+' : '') + v.toFixed(1) : '-';
                }),
            });

            rows.push({
                label: 'Weighted Luck',
                values: luckResults.map(l => {
                    const v = l?.data?.total_weighted_luck;
                    return v != null ? (v > 0 ? '+' : '') + v.toFixed(1) : '-';
                }),
            });

            return rows;
        },
    };
}
</script>
{% endblock %}
